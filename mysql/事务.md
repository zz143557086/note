### 事务的特性

```
ACID
A 原子性 undolog实现的
事务作为一个整体被执行，包含在其中的对数据库的操作要么全部都执行，要么都不执行
C 一致性 通过 原子性  一致性 永久性来保证的
指在事务开始之前和事务结束以后，数据不会被破坏
I 隔离性 mvcc实现的
多个事务并发访问时，事务之间是相互隔离的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离。
D 永久性 redolog实现的 redolog是innodb才有的 binlog是server层才有的 修改更新后innodb会将修改放入redolog设置一个状态事务commit后才会将redolog1的状态设为commit状态 
表示事务完成提交后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。
redolog记录事务的已提交更改操作
binlog 记录了对数据库进行的所有更改操作 作用是记录数据库中的更改，以便在需要时进行数据复制和恢复
undolog 主要作用是支持事务的回滚操作
```

### 事务并发存在的问题

##### 脏读:如果一个事务读取到另一个未提交事务修改过的数据，我们就称发生了脏读现象

- 假设现在A的余额是100，事务A正在准备查询Jay的余额
- 事务B先扣减Jay的余额，扣了10，但是还没提交
- 最后A读到的余额是90，即扣减后的余额

##### 不可重复读:同一事务内，前后多次读取，读取到的数据内容不一致

- 事务A先查询Jay的余额，查到结果是100
- 这时候事务B 对Jay的账户余额进行扣减，扣去10后，提交事务
- 事务A再去查询Jay的账户余额发现变成了90

#####  幻读:如果一个事务先根据某些搜索条件查询出一些记录，在该事务未提交时，另一个事务写入了一些符合那些搜索条件的记录（如insert、delete、update），就意味着发生了**幻读**。

- 事务A先查询id大于2的账户记录，得到记录id=2和id=3的两条记录
- 这时候，事务B开启，插入一条id=4的记录，并且提交了
- 事务A再去执行相同的查询，却得到了id=2,3,4的3条记录了。

### 四大隔离级别

#####  读未提交

读未提交隔离级别，只限制了两个数据**不能同时修改**，但是修改数据的时候，即使事务**未提交**，都是可以被别的事务读取到的，这级别的事务隔离有**脏读、重复读、幻读**的问题；

##### 读已提交

读已提交隔离级别，当前事务只能读取到其他事务**提交**的数据，所以这种事务的隔离级别**解决了脏读**问题，但还是会存在**重复读、幻读**问题；

##### 可重复读

可重复读隔离级别，限制了读取数据的时候，不可以进行修改，所以**解决了重复读**的问题，但是读取范围数据的时候，是可以插入数据，所以还会存在**幻读**问题；

#####  串行化

事务最高的隔离级别，在该级别下，所有事务都是进行**串行化顺序**执行的。可以避免脏读、不可重复读与幻读所有并发问题。但是这种事务隔离级别下，事务执行很耗性能。

### mvcc 多版本并发控制 解决加锁后的性能问题

数据库隔离级别读**已提交、可重复读** 都是基于MVCC实现的

#### MVCC实现的关键知识点

#####  事务版本号

事务每次开启前，都会从数据库获得一个**自增**长的事务ID，可以从事务ID判断事务的执行先后顺序。这就是事务版本号。

##### 隐式字段

对于InnoDB存储引擎，每一行记录都有两个隐藏列**trx_id**、**roll_pointer**，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列**row_id**。

- DB_TRX_ID:创建或最后修改的记录ID 事务id
- DB_ROW_ID:隐藏主键 当一条记录没有主键的时候就会默认创建一条主键
- DB_ROll_PTR:回滚指针，undo log  当一条记录执行失败了需要回滚到之前的记录中，当前指针就指向上一个对应的历史记录

##### 版本链

多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为**版本链**

### undolog 

undo log，**回滚日志**，用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据。

```
mysql在创建记录时回创建这几个隐藏的字段 事务id默认是1 回滚指针默认时null
事务中记录的每一次修改 id都回增加 undolog的指针就是上一次记录的地址
```

#### 快照读和当前读

- **快照读：** 读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读
- **当前读**：读取的是记录数据的最新版本，显式加锁的都是当前读

#### 查询一条记录，基于MVCC，是怎样的流程

1. 获取事务自己的版本号，即事务ID
2. 获取Read View
3. 查询得到的数据，然后Read View中的事务版本号进行比较。
4. 如果不符合Read View的可见性规则， 即就需要Undo log中历史快照;
5. 最后返回符合规则的数据

### 数据提交的过程 两阶段提交

```
1.mysql向服务发起更新数据请求
2.服务器修改数据提交给存储引擎innodb 
3.存储引擎将修改的数据提交给内存
4.修改更新后innodb会将修改放入redolog设置一个状态
5.innodb向服务器响应数据修改成功可以提交了
6.服务器将数据写入binlog
7.服务器向innodb提交事务
8.redolog的状态设为提交
恢复数据用binlog 和 redolog比较恢复就行了
```

![undolog](../image/undolog.png)
