### TCP报文格式

```
1.报头:16位源端口号 16位目的端口号 32位序号->seq 32位确认序号->ack 连接端的seq+1
4位首部长度 保留6位 URG ACK PSH RST SYN FIN(每一个代表一个标准类) 16位窗口大小
ACK:确认序号有效
SYN:确认发起一个连接
FIN:确认结束一个连接
16位校验和 16位紧急指针 32位选项

2.数据:32位数据
```

### TCP三次握手 保证建立一个安全可靠的连接

```
TCP 协议是传输层的一个面向连接的安全可靠的一个传输协议，三次握手的机制是为了保证能建立一个安全可靠的连接
1.第一次握手是由客户端发起，客户端会向服务端发送一个报文，在报文里面：SYN标志位置为1，表示发起新的连接。2.服务端收到这个报文之后就知道客户端要和我建立一个新的连接，
2.第二次握手是服务端就向客户端发送一个确认消息包，在这个消息包里面：ACK标志位置为1，表示确认客户端发起的第一次连接请求。
3.第三次握手，第三次握手就是当客户端收到服务端发送的确认响应报文之后，还要继续去给服务端进行回应，也是一个ACK标志位置1的确认消息。

为什么不是两次握手:
两次握手之后，对于客户端而言：已经明确了我既能给服务端成功发消息，也能成功收到服务端的响应。但是对于服务端而言：两次握手是不够的，因为到目前为止，服务端只知道一件事，客户端发给我的消息我能收到，但是我响应给客户端的消息，客户端能不能收到我是不知道的。所以，还需要进行不管是客户端还是服务端，都知道我既能给对方发送消息，也能收到对方的响应。


每一次请求的都发送一个 seq32位请求序列 第一个seq是随机创建
确认请求 都会发送一个ack 32确认请求序列 请求seq+1
```

### tcp的四次挥手 断开连接

```
1.第一次挥手客户端会发送一个报文，在报文里面FIN标志位置1，当服务端收到这个报文就知道了客户端想要和我断开连接
但是此时服务端不一定能做好准备，因为当客户端发起断开连接的请求后，对于服务端而言还极有可能有未发送完的消息，还需继续发送，所以此时对于服务端而言只能进行一个消息确认
2.第二次挥手，即告诉客户端我知道你要和我断开连接，但是我这边还可能没有做好准备，你需要等我一下，等会儿我会告诉你
3.第三次挥手，于是，发完这个消息确认包过后，可能稍过片刻，服务端会继续发送一个断开连接的报文（第三次挥手），FIN位置1的报文，表示服务端已经做好断开连接的准备，当这个报文发给客户端的时候，客户端同样要给服务端发送一个消息确认的报文
4.第四次挥手，经过这四次的相互沟通和连接，我就知道了不管是客户端还是服务端都已经做好了断开连接的准备，于是连接断开了

每一次请求的都发送一个 seq32位请求序列 seq会随着发送报文增长
确认请求 都会发送一个ack 32确认请求序列 请求seq+1
```

### 图解

![tcp的三次握手和四次挥手](F:\笔记\网络\tcp的三次握手和四次挥手.png)

### 通俗理解

```
【三次握手】
男：我们在一起吧
女：好的啊
男：好的，从现在开始吧
【四次挥手】
男：我们分手吧
女：我想一下
女：我们分手吧
男：好的，现在就结束吧
```

### UDP协议

```
类似于写信 将数据传输出去不能确认对方是否收到
优点:资源占用少 性能高
缺点:稳定性差
```

