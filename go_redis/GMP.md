G表示轻量级线程即协程

M表示内存级别线程

P表示调度器是一个本地队列  负责调度G到M中执行，同时还负责部分内存管理

## 调度策略

1. 当创建一个goroutine后，该G会优先放入P的本地运行队列(随机寻找一个P)，等待执行，放入P的runnext(插队执行)
2. 如果此时的P队列已满，则将G放入全局队列等待执行
3. M如果已经处理完自己的P队列里的任务后，会尝试从全局队列拉取G任务来执行
4. 如果此时全局队列仍然无任务可执行，则会尝试从其他P队列尾部获取可执行的任务，这称为工作量窃取。每次从其他P队列尾部窃取任务，每次窃取一半。
5. 当发生系统调用时，G会被阻塞，M会释放P，而原来的P队列将由新的M来接管，继续完成执行G的工作。这里接替的M的来源可以是缓存池中休眠的M，也可能是系统新创建出来的M，不过是先优先取缓存池的M，后考虑新建M。
6. 当被系统调用阻塞的G结束系统调用后，G需要被继续执行，此时需要找一个P完成接下来的工作，这里的策略是优先从空闲P池子里取出P来执行，若无空闲P，则将该G放如全部队列，等待调度执行。
7. Go 1.14版本支持了基于信号通知的抢占式调度。在此之前，Go的抢占式调度是基于函数调用间隙检查协程是否可以被抢占，这里有个问题，如果没有发生函数调用，就没法进行抢占了，如一个协程内的for循环`for {}`，因为这段逻辑没有调用函数，因此goroutine一直占用cpu，且不会被其他协程抢占，因此会无限期地占用执行权。1.14版本后，引入了基于信号的异步抢占机制，即对占用执行权时间过长的协程发送信号通知，收到信号的G就主动让出CPU，自己重新进入P队列等待下次调度。
8. G产生一个新G时，这个新G优先放在跟G相同的本地队列（局部性），之后再考虑放到其他的P队列，最后再考虑放到全局队列。