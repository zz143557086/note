### cgo

1.在内存中开辟一个结构体

2.结构体中含有参数和返回值

3.结构体地址传入c方法

4.c方法将结果写入返回值的位置

### defer

#### 思路1 堆上分配 1.12之前使用

1.在堆上开辟一个sched.deferpool

2.遇到defer语句，将信息放入deferpool

3.函数返回时，从deferpool取出执行 

#### 思路2 栈上分配 1.13之后使用

1.遇到defer语句。将信息放入栈上

2.函数返回时，从栈中取出执行

3.只能保存一个defer信息

#### 思路3 开放编码 1.14之后出现的

1.如果defer语句在编译时可以固定

2.直接改写用户代码，defer放入函数末尾

### panic基本使用

1.panic会抛出错误

2.终止协程允许

3.带崩整个go程序

4.panic退出协程之前会执行所有已注册的defer，不会执行其他协程的defer

### recover的使用

#### 1.在defer中执行recover，可以拯救panic的协程

1.如果涉及到recover，defer会使用堆上分配

2.遇到panic，panic会从deferpool取出的defer语句，执行

3.defer中调用recover，可以终止panic的协程

### Go中的反射 检查变量具体的类和值

#### 需求

**函数泛化**

1.获取对象类型

2.对任意类型变量赋值

3.调用任意方法

#### 元数据

1.元数据就是“数据的数据”

2.把对象的类型表示成一个数据类型

3.把对象的值表示成一个数据类型

#### 对象的类型

1.接口reflect.TypeOf  

2.把对象的类型表示成一个接口

3.对类型做各种操作

4.reflect.TypeOf.Kind 类型的种类

#### 对象的值

1.结构体reflect.ValueOf

2.把对象的值表示成一个结构体

3.对值做各种操作

#### 使用反射调用

1.通过反射调用方法，可以将框架和用户方法解耦

2.往往需要用户注册方法，框架调用

3.很多框架的HTTP调用处理使用次思路

#### 反射三法则

1.从接口值可以反射出反射对象。

2.从反射对象可反射出接口值。

```
v := reflect.ValueOf(1)
v.Interface{}.(int)
```

3.要修改反射对象，其值必须可设置。

反射获取结构体的方法

```
// 获取一个结构体内的字段数量
NumField() int
// 根据 index 获取结构体内字段的类型对象
Field(i int) StructField
// 根据字段名获取结构体内字段的类型对象
FieldByName(name string) (StructField, bool)
```

