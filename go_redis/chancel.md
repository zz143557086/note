### Channel的基本使用

```go
ch<-x //发送数据x
x=<-ch // 接收数据，赋给x
<-ch // 接收数据，并丢弃 
没有缓冲区的管道往里面塞东西会卡住，在等待接收的情况下没缓冲区往里面塞东西不会卡住
```

不要通过共享内存的方式来通信，而是要通过通信的方式来共享内存

### Channel发送数据的三种逻辑

编译阶段,会把<-转换为runtime.chansend1()

#### 直接发送

1.发送数据前，已经有G在休眠等待接收

2.此时缓冲肯定是空的，不要考虑缓存

3.将数据直接拷贝给G的接收变量，唤醒G

#### 放入缓存

1.获取可存入的缓存地址

2.存入数据

3.维护索引

#### 休眠等待

1.没有G在休眠等待，而且没有缓存或满了

2.自己进入发送队列，休眠等待

3.把自己包装成sudog,sudog放入sendq队列，休眠并解锁，被唤醒后数据已经被取走了

### Channel数据接收的原理

1.编译阶段<-c会转换为chanrecv()

2.有等待的G，且无缓冲，从G接收

3.有等待的G，且有缓存时，从缓存接收

4.无缓冲的G，且缓存有数据，从缓存接收

5.无缓存的G，且缓存无数据，等待喂数据

