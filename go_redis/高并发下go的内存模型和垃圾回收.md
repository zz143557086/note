### Go协程栈的作用

1.协程的执行路径

2.局部变量

3.函数传参

4.函数返回值

### Go协程栈的位置

1.c,c++:栈和堆是分开的 ，go栈的内存是从堆上申请的。协程栈位于go堆内存上

2.Go堆内存位于操作系统虚拟内存上

###  Go协程栈的结构

#### 1.每一个函数开辟一个栈帧

![Go协程栈的结构](images\Go协程栈的结构.png)

2.go传参方式拷贝传递(值传递)

3.传递结构体:会拷贝结构体中的全部内容

4.传递结构体指针时:会拷贝指针

### 逃逸分析 

#### 指针逃逸

1.函数返回了对象的指针，作为函数参数也会发送逃逸

#### 空接口逃逸

**函数接受一个空接口作为参数，类型断言需要函数内部使用反射来检查其具体类型或值，编译器可能会决定将空接口的数据逃逸到堆上**

1.如果函数参数为interface{}很可能会逃逸

2.因为interface{}类型的函数往往会使用反射，使用反射查看时什么类型一般是在堆上

#### 大变量逃逸

1.过大的变量会导致栈空间不足

2.64位机器中，一般超过64KB的变量会逃逸

### 栈扩容

1.Go栈的初始空间位2KB

2.在函数调用前判断栈空间(morestack)，必要时堆栈进行扩容

3.1.13以前时分段栈，后期使用连续栈(开辟新的空间为原来两倍将老的拷贝过来，使用率不足1/4变为1/2)

### heapArena(堆内存分配)

1.线性分配，链表分配不能利用碎片化空间

2.分级分配  将内存分级分为内存单元(mspan)，内存匹配放入最小内存单元

#### 3.中心索引

1.136个mcentral结构体，其中68个组需要GC扫描的mspan，68个不需要GC扫描的mspan

2.mcentral实际时中心索引，使用互斥锁保护

3.在高并发场景下，锁冲突问题严重

4.参考协程GMP模型，增加线程本地缓存

#### 4.线程缓存

1.每个p拥有一个mcache对应mcentral

2.mcache记录了分配到各个p的本地mspan

### 堆上分配内存

#### 对象分级

1.Tiny微对象(0,16B)无指针（分配至普通的mspan）

2.Small小对象[16B,32KB]

3.Large大对象(32kB,正无穷) （量身定做mspan）

### go的GC

#### 垃圾回收思路

**1.标记-清除（go使用）**

2.标记整理

3.赋值 

#### 什么样的对象不被GC（GC Root）

1.被栈上的指针引用

2.被全局变量指针引用

3.被寄存器中的指针引用

#### 三色标记法 

**从根出发扫描可达性对象标记为灰色，扫描灰色对象，将其引用的对象标记为灰色，自身标记为黑色。再次标记时恢复为白色**

1.黑色:有用，已经分析扫描

2.灰色：有用，还未分析扫描

3.白色：暂时无用

#### 并发的问题解决 并发标记时

1.指针被释放就需要将释放的指针置为灰色(删除屏障也叫快照标记)

2.对指针新指向的白色对象置为灰色（插入屏障）

go二者都使用了(混合屏障)

#### GC触发

1.sysmon定时检查

2.如果2分钟内没有出发过GC，触发

3.用户调用runtime.GC方法

#### GC优化原则

##### 1.经量少在堆上产生垃圾

​	1.内存池化

​	2.减少逃逸

​	3.使用空结构体

#### 串行GC步骤

1.Stop The world，暂停所有其他协程

2.从根出发通过可达性分析（广度优先），找到无用的堆内存

3.释放堆内存

4.恢复所有其他协程

问题:STW对性能影响很大

#### GC分析工具:

GODEBUG="gctrace=1"

go run main.go

#### Go栈内存管理

栈上的内存管理是自动的，不需要垃圾回收。Go 的运行时环境（runtime）会负责管理函数调用栈上的内存，包括函数的局部变量和控制流信息。当函数调用结束时，它的局部变量会自动被销毁，不再被引用的数据会被垃圾收集。