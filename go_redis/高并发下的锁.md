### 互斥锁

mutex正常模式:自旋加锁+sema休眠等待

mutex正常模式下，可能有锁饥饿的问题

### Mutex饥饿模式

1.当前协程等待锁时间超过10ms，切换到饥饿模式

2.饥饿模式中，不自旋，新来的协程直接sema休眠

3.饥饿模式中，被唤醒的协程直接获取锁

4.没有协程在队列中继续等待，回到正常模式

5.锁竞争严重时，互斥锁进入饥饿模式

6.饥饿模式没有自旋等待，有利于公平

### 使用经验

1.减少锁的使用时间

2.擅长使用defer释放锁

### 多个协程同时只读

1.只读时，让其他人不能修改即可

2.只读时，多协程可以共享读

3.只读时，不需要互斥

### 读写锁需求 读锁Rlock 写锁Wlock

1.每个锁分为读锁和写锁,写锁互斥

2.没有加写锁时，多个协程都可以加读锁

3.加了写锁时，无法加读锁，读协程排队等待

4.加了读锁，写锁排队等待

### 解写锁 

1.将readerCount变正值，允许读锁的获取

2.释放在readerSem中等待的读协程

3.解锁mutex

### 加读锁 Rlock

1.将给readerCount无脑加一

2.如果readerCount是正数，加锁成功

3.如果readerCount是负数,说明被加了写锁，陷入readerSem

### 解读锁

1.给readerCount减一

2.如果readerCount是正数，解锁成功

#### 3.如果readerCount是负数,有写锁在排队

​	如果自己是readerWait的最后一个，唤醒写协程

### 使用经验

1.RW锁适合读多写少的场景，减少锁冲突

### 读写锁总结

1.mutex用来写协程之间的互斥等待

2.读协程使用readerSem等待写锁的释放

3.写协程使用writeSem等待写锁的释放

4.readerCount记录读协程格式

5.readerWait记录写协程之前的读协程个数

### waitGroup

1.waitGroup实现了一组协程等待另一组协程

2.等待的协程陷入sema并记录个数

3.被等待的协程计数归零时，唤醒所有的sema中的协程

### sync.once

方法只执行一次



