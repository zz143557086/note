



```
gRPC是一种高性能、通用的远程过程调用（RPC）框架，由Google开发并开源。它建立在HTTP/2协议的基础之上，并使用Protocol Buffers作为接口定义语言
```

### 什么是protobuf为什么需要

```
一种轻量高校的结构化的数据存储格式 
优点:性能高,支持各种语言，加密性好，维护成本低，跨语言，跨平台
缺点:通用性差，自己解释性差

protobuf 可以通过
protoc -I . (proto文件) --go_out=plugins=grpc:. 命令直接生成客服端和服务端存根
-I input 生成 .当前目录 --go_out 生成语言 
plugins=grpc:. 生成go语言的时候要用grcp插件
```

### grpc的使用过程

```
1.用protobuf定义服务接口和消息类型
生成代码：使用protobuf编译器将.proto文件编译成对应的编程语言代码。编译器会根据.proto文件生成服务和消息类型的代码，供开发者在项目中使用。

2.实现服务：根据生成的代码，在handler中实现proto接口。这通常包括定义一个结构体并实现.proto文件中定义的服务接口。

3.启动gRPC服务器：在服务端启动代码中，创建TCP监听，并将实现的gRPC服务注册到服务器上。

4.客户端调用：在客户端代码中，使用生成的代码创建一个gRPC客户端对象，并通过该对象调用远程服务的方法。

5.序列化和反序列化：客户端和服务器之间的消息传递是通过序列化和反序列化完成的。gRPC使用protobuf进行消息的序列化和反序列化，使得数据在网络传输中更加高效。

流程 客服端 通过客服端存根请求服务端和接收服务端的结果  protobuf生成了客服端存根 将请求消息序列化 返回的结果反序列化 
	服务端 通过服务端存根接收客服端的请求然后处理返回结果 protobuf生成了服务端存根 客服端的请求消息反序列化 将服务端返回的结果消息序列化 
客服端存根封装远程服务的细节 服务端存根接收来自客户端的请求并处理它们
```

### 负载均衡

```
src服务有多个机器
web层grpc调用 srv层 访问哪一个机器的服务称为负载均衡策略
网关解决web层的负载均衡
网关是多个的也需要负载均衡
```

### 分布式

```
一个服务暴露给多个协程同时使用
```

