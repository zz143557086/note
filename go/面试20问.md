##### 1.make 和 new 的区别？

```
make 仅支持 slice、map、channel 三种数据类型的内存创建，其返回值一个初始化的对象

new 可以对类型进行内存创建和初始化。其返回值是所创建类型的指针引用初始值为0

make 函数在初始化时，会初始化 slice、chan、map 类型的内部数据结构
```

##### 2.调用函数传入结构体时，应该传值还是指针﹖说出你的理由?

```
一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。

对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。
```

##### 3.线程有几种模型?Goroutine的原理了解过吗，讲一下实现和优势?

```
线程的实现模型主要有3个，分别是:内核级线程模型、用户级线程模型和两级线程模型。用户线程和内核级线程对应关系1:1,m:1,m:n

Goroutine使用的是用户级线程模型用户线程和内核级线程对应关系m:1
 
一个Goroutine会以一个很小的栈启动2KB或4KB，当遇到栈空间不足时，栈会自动伸缩，
因此可以轻易实现成千上万个goroutine同时启动。并且上下文切换性能消耗比起操作线程更低

main也是第一个协程被称为主线程
```

##### 4.Goroutine什么时候会发生阻塞?

```
通道里数据为空（channel）接收数据会堵塞
通道里数据已满，（channel）发送数据会堵塞
```

##### 5.每个线程/协程占用多少内存知道吗? 

```
协程占用的内存小,大概2KB左右,线程占用内存大概1-2MB。
```

##### 6.如果Goroutine—直占用资源怎么办,PMG模型怎么解决的这个问题?

```
如果有个goroutine一直占用资源，那么GMP模型会从正常模式转变为饥饿模式（类似于mutex），允许其它goroutine使用work stealing抢占（禁用自旋锁）。
 
work stealing算法指，一个线程如果处于空闲状态，则帮其它正在忙的线程分担压力，从全局
队列取一个G任务来执行，可以极大提高执行效率。
```

##### 7.如果若干线程中一个线程OOM，会发生什么?如果是Goroutine 呢?

```
OOM是指"Out of Memory"，即内存耗尽或内存不足
1. 线程发生OOM，也就是内存溢出，发生OOM的线程会被kill掉，其他线程不会受到影响
 
2. go中的内存泄露一般都是Goroutine泄露，就是Goroutine没有被关闭或者没有添加超时控制，让Goroutine一直处于阻塞状态，不能被GC
```

##### 8.项目中错误处理是怎么做的?

```
error，
goroutine中有panic需要recover，不然会中断程序
```

##### 9.如果若干个Goroutine,其中有一个panic，会发生什么?

```
导致程序主线程崩溃，切记要回收panic
```

##### 10.defer可以捕获到其Goroutine的子Goroutine 的panic吗?

```
defer只能捕获本层的panic，不能捕获子Goroutine的panic
```

##### 11.开发用Gin框架吗?Gin怎么做参数校验?

```
Gin 是 Go语言写的一个 web 框架,它具有运行速度快,分组的路由器,良好的崩溃捕获和错误
处理,非常好的支持中间件和 json。
```

##### 12.中间件使用过吗?怎么使用的。Gin的错误处理使用过吗?Gin中自定义校验规则知道怎么做吗?自定义校验器的返回值呢?

```
中间件middlewares使用use方法，gin的中间件其实就是一个HandlerFunc，只要我们实现一个HandlerFunc，然后作为参数传递进去
 
Gin对请求参数自定义验证规则可以分三步：
 
自定义结构体验证绑定binding标签
针对该标签定义验证方法
再将该验证方法注册到validator验证器里面
```

##### 13.golang中解析tag是怎么实现的？反射原理是什么？通过反射调用函数

```
反射
具体来说使用reflect.ValueOf方法获取其反射值，然后获取其Type属性，之后再通过Field(i)
获取第i+1个field，再.Tag获得Tag
```

##### 14.golang的锁机制了解过吗? Mutex的锁有哪几种模式，分别介绍一下? Mutex锁底层如何实现了解过吗?

```
用于保护共享资源，防止并发访问产生的竞态条件

正常模式、饥饿模式
正常模式就是会没有公平性，新进的协程和自旋很久的线程谁抢到谁执行。
饥饿模式会采取队列模式，先到先得，有公平性。
Mutex 只能由持有锁的 Goroutine 来解锁
```

##### 15.channel、channel使用中需要注意的地方？

```
Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或
者接收数据进行通讯(communication)。
 
它的操作符是箭头 <- 
 
容易阻塞，考虑使用select解决或者使用waitgroup
```

16.数据库用的什么？数据库锁有了解吗？mysql锁机制讲一下。mysql分库分表。

```
MySQL Redis
 
数据库锁的种类一般分为两种：一种是悲观锁，一种乐观锁。
 
悲观锁（Pessimistic Lock）具有强烈的独占和排他特性，它指的是对数据被外界修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。
 
相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制，大多是基于版本号（ Version ）记录机制实现，而不需要借助数据库的锁机制。
 
当一张表的数据达到千万级时甚至亿级时，查询一次所花的时间会变多，如果有联合查询的话可能会死在那儿了。分表的目的就在于此，减小数据库的负担，缩短查询时间。
 
分表：将一个表中的数据按照某种规则分拆到多张表中，降低锁粒度以及索引树，提升数据查询效率。
分库：将一个数据库中的数据按照某种规则分拆到多个数据库中，以缓解单服务器的压力（CPU、内存、磁盘、IO）。
 
1.垂直拆分：
1.1)垂直拆表
即大表拆小表，将一张表中数据不同”字段“分拆到多张表中，比如商品库将商品基本信息、商品库存、卖家        信息等分拆到不同库表中。
考虑因素有将不常用的，数据较大，长度较长（比如text类型字段）的拆分到“扩展表“，表和表之间通过”主键外键“进行关联。
好处：降低表数据规模，提升查询效率，也避免查询时数据量太大造成的“跨页”问题。
 
1.2)垂直拆库
垂直拆库则在垂直拆表的基础上，将一个系统中的不同业务场景进行拆分，比如订单表、用户表、商品表。
好处：降低单数据库服务的压力（物理存储、内存、IO等）、降低单机故障的影响面
2.水平拆分：
操作：将总体数据按照某种维度(时间、用户)等分拆到多个库中或者表中，典型特征不同的库和表结构完全一下，如订单按照(日期、用户ID、区域)分库分表。
2.1) 水平拆表
将数据按照某种维度拆分为多张表，但是由于多张表还是从属于一个库，其降低锁粒度，一定程度提升查询性能，但是仍然会有IO性能瓶颈。
2.2) 水平拆库
将数据按照某种维度分拆到多个库中，降低单机单库的压力，提升读写性能。
```

##### 17.讲一下redis分布式锁？redis主从模式和集群模式的区别了解过吗？redis的数据类型有哪些？redis持久化怎么做的？

```

分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。
1.SETNX + EXPIRE
即先用setnx来抢锁，如果抢到之后，再用expire给锁设置一个过期时间，防止锁忘记了释放。
2.SET的扩展命令（SET EX PX NX）
除了使用，使用Lua脚本，保证SETNX + EXPIRE两条指令的原子性，我们还可以巧用Redis的SET指令扩展参数！（SET key value[EX seconds][PX milliseconds][NX|XX]），它也是原子性的！
问题一：「锁过期释放了，业务还没执行完」,可以考虑使用watch dog看门狗机制隔断时间延长expire
问题二：「锁被别的线程误删」
3.多机实现的分布式锁Redlock
1.获取当前时间，以毫秒为单位。
2.按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。
3.客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s> 30ms+40ms+50ms+4m0s+50ms）
如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。
如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。
简化下步骤就是：
 
按顺序向5个master节点请求加锁
根据设置的超时时间来判断，是不是要跳过该master节点。
如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。
如果获取锁失败，解锁！
```



##### 18.PMG模型中Goroutine有哪几种状态? 

```
_Gidle：刚刚被分配并且还没有被初始化，值为0，为创建goroutine后的默认值
 
_Grunnable： 没有执行代码，没有栈的所有权，存储在运行队列中，可能在某个P的本地队列或全局队列中(如上图)。
 
_Grunning： 正在执行代码的goroutine，拥有栈的所有权(如上图)。
 
_Gsyscall：正在执行系统调用，拥有栈的所有权，与P脱离，但是与某个M绑定，会在调用结束后被分配到运行队列(如上图)。
 
_Gwaiting：被阻塞的goroutine，阻塞在某个channel的发送或者接收队列(如上图)。
 
_Gdead： 当前goroutine未被使用，没有执行代码，可能有分配的栈，分布在空闲列表gFree，可能是一个刚刚初始化的goroutine，也可能是执行了goexit退出的goroutine(如上图)。
 
_Gcopystac：栈正在被拷贝，没有执行代码，不在运行队列上，执行权在
```
