### 分布式事务

本地数据处理和远程数据库处理在一个事务执行保证其原子性和数据一致性

```
为什么订单会有超时机制？
解决库存归还的问题

超时机制引发的问题
如果出现网络拥塞 库存服务已经扣减了但是久久没有返回数据 订单就会取消导致库存减少订单没有生成的问题
```

![订单超时机制和分布式事务](C:\Users\zz143\Desktop\go\微服务\前后端\订单超时机制和分布式事务.png)

```
分布式事务 由本地多个事务组合而成 
分布式事务的主要是在多个节点之间保持一致的数据状态和处理结果
```

```
哪些问题会导致数据不一致？
网络问题 比如订单服务创建订单时 1.减少库存时库存减少完成 但是网络出现问题返回数据失败导致 订单并没有创建 出现库存扣除却没有订单生成的情况
```

```
cap理论:
c 一致性 数据始终一致性
a 可用性 服务一直可用
p 分区容错性 某一个节点挂了后，仍然能够提供服务
更新操作返回节点后所有节点在同一时间数据完全一致 举例数据库的主从复制 主数据库写数据 同步数据一致 从数据库读数据 
在同步时间 访问数据就无法访问到数据  一致性和可用性是互斥的
```

```
base理论:
ba 基本可用 允许损失一部分可用性 1.响应时间的损失：比如搜索系统 正常时0.5秒返回搜索结果 网络故障时延迟1-2秒返回查询结果
2.系统功能上的损失：购物系统在高峰情况下 将部分消费者引导到一个降级页面
s 软状态 允许系统中的数据存在中间状态
e 最终一致性 数据的最后结果是一致的
cap不能实现 base才是合理的

```

```
2pc两阶段提交
比如订单服务 调用库存服务 第一阶段开始事务
确认库存扣减发起一个请求 进入第二节点commit操作 
在参与者处理提交阶段时，可能需要涉及到加锁的操作以确保数据的一致性
性能问题 1.数据库事务会加锁 参与者和协调者都会被锁住
2.参与者进行本地事务后才会释放资源
```

```
tcc分布式事务
Try阶段（尝试阶段）：在Try阶段中，事务参与者尝试执行事务操作，并预留相关资源。在这个阶段，业务系统会检查所有资源是否可用，并执行相关的预操作，但这些预操作不会对实际数据产生影响。

Confirm阶段（确认阶段）：如果所有参与者都成功完成了Try阶段的操作，那么在Confirm阶段中，各个参与者会执行真正的业务操作，并提交所做的更改。在这个阶段，事务的一致性得到了确认。

Cancel阶段（撤销阶段）：如果任何一个参与者在Try阶段或Confirm阶段失败，或者整个事务超时，就会进入Cancel阶段。在这个阶段，各个参与者会执行相反的操作来恢复到事务开始前的状态，释放之前预留的资源。

try阶段尝试后会预留相关资源 如果所有参与者都完成了try阶段那么会执行真正的业务操作使用预留的资源 如果有一个参与者没有完成try会释放预留的资源
实现分布式事务管理根据活动日志 会不断重试confirm确保不是网络问题 下一次启动会根据日志完成未完成的
缺点
选择tcc事务框架 实现分布式事务管理根据活动日志 会不断重试confirm确保不是网络问题 下一次启动会根据日志完成未完成的
如果confirm阶段网络问题超时还是回返回执行cancel
保证数据一致性也会在业务端加锁
业务逻辑的侵入性太强了 一个接口变为3个接口 需要改表结构 维护成本高

优点 1.解决业务操作的原子性问题 比如组合支付，订单删除库存
 2.tcc异步高性能 
 3.避免二阶段数据库锁冲突长事务低性能
```

```
基于可靠消息的最终一致性
比如订单服务执行后将消息放入mq队列
库存服务和通知服务向mq队列获取消费消息 消息消费后会消失
特点虽然当前数据还没有数据一致，但是最终一定会一致

1.MQ发送方 发送 half消息 给rocketmq
2.rocketmq 收到消息返回发送成功 给MQ发送方
3.MQ发送方执行本地事务
4.MQ发送方 commit/rollback 给rocketmq执行

5.如果MQ发送方长时间没有给rocketmq发送消息 rocket会向MQ发送方回查消息 为commit还是为rollback
6.MQ发送方收到回查请求会向查询本地事务状态
7.回查到本地事务状态向rocketmq返回状态

最后 消息为commit向mq订阅费投递消息
消息为rollback则丢弃消息

rocketmq重要机制消息回查 
优点 1.业务逻辑简单 2.高并发
```

