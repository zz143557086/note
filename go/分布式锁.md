```go
/*并发扣减的时候会出现数据不一致的问题 并发情况下会出现超卖的问题
原因 假设库存有100件 g1 g2两个协程并发执行 g1 g2都是通过查询库存 判断库存逻辑运算 更新库存 因为是并发执行的g1查询到100件还没更新g2查询到也是100件 假设都是买一件 两边都是100-1 更新的时候两边都是100-1  明明卖了2件库存却只减了1
锁 解决1. 在查询前先获取锁 更新后释放这把锁
var m sync.Mutex 定义锁 m.Lock()//查询前获取锁 m.Unlock更新后释放锁 如果是同一把锁性能下降会很厉害

分布式锁的解释：当一个节点想要获取锁时，它会在共享存储中创建一个特定的标识来表示该节点已经获取了锁。其他节点在尝试获取锁时，会检查共享存储中的标识来确定是否已经有节点获取了锁。如果已经有节点获取了锁，则其他节点需要等待，直到锁被释放。
```

```
mysql分布式锁 解决2.
mysql悲观锁:认为协程总是会冲突，先锁住//性能不足mutex思想
mysql请求锁在语句最后加上一个 for update//for 锁 update语句 只会锁update语句
请求锁为行锁只会锁住符合条件的语句，只有字段有索引的情况会是行锁。如果没有索引行锁会升级为表锁 无论是否查询到结果都会锁表
提交事务相当于锁的释放 gorm中加锁为tx.Clauses(clause.locking(strength:"UPDATE"))
优点：1. 简单
2. 不需要额外的组件 - 维护，mysql的维护比较简单 - 最合适的才是最好的。 系统的可用性
缺点：性能
```

```
乐观锁 在查询的时候两个协程都会查询库存和版本号
在最后更新的时候where为goods和版本号 如果版本为查询时候的版本号才会执行 同时更新内容有版本号+1
如果两个协程同时获得库存100 版本号为0 总有一个协程成功更新版本号变化导致另一个协程版本号不一致更新失败 失败后for循环再次执行
```

```
redis分布式锁 解决3:
创建一个分布式锁 根据商品id给锁命名 mutex := rs.NewMutex(mutexname)根据锁门获取锁

实现原理：比如多个协程并发 步骤1.先判断name锁是否存在值是否为1 步骤2.如果没有设置name为1并获取锁 如果已经存在就轮询等待 步骤3. 业务逻辑 步骤4.删除name这个key。
问题1：在1，2操作的时候高并发情况下1操作可以同时执行，导致多个服务占用锁解决这个问题采用setnx命令将1，2步骤变为1个步骤，将name设置为1保证其原子性
问题2：一个协程以及设置了key值在执行中挂掉了导致锁无法释放导致其他协程死锁 解决设置过期时间 
问题3：在过期时间结束后业务逻辑还没结束 redis内部也会自动刷新过期时间 需要自己协程刷新
问题4：删除value值是需要改协程删除

setnx:如果 key 不存在，则设置当前 key 成功，返回 1；如果当前 key 已经存在，则设置当前 key 失败，返回 0。
```

```
基于redis的分布式锁
优点：
性能高
简单
redis本身使用很频繁，这样的话我们不需要去额外维护
缺点：
  a. 依赖了第三方组件
  b. 单机的redis挂掉的可能性相对较高 - redis的cluster redis的sentinel
  c. redis的cluster的引入会导致刚才的redis的锁会有些问题 - redlock 
```

```
redsync源码解读
1.setnx的作用
	将获取的设置值变为原子性的操作
2.如果我的服务挂掉了-死锁
	a.设置过期时间
	b.如果你设置了过期时间，那么过期时间到了我的业务逻辑没有执行完怎么办？
		i.在过期之前刷新一下
		ii.需要自己去启动协程完成延时的工作
			1.延时的接可能带来负面影响-如果其中一个服务hung住了2s就能执行完，那么你hung住的协程就会一直申请延长锁，导致别人永远得不到
3.分布式锁需要解决的问题-lua脚本去做
	a.互斥性-setnx
	b.死锁
	c.安全性
		i.锁只能被持有该锁的用户删除，不能被其他用户删除
			1.当时设置的value值是多少只有当时的g才能知道
			2.在删除的时候去除redis中的值和自己当前保存下来的值对比一下
4.即使你这样实现分布式但是还是有问题-redlock
```

