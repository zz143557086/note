#### 内存逃逸

```
golang程序变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在栈上分配。否则就说它 逃逸 了，必须在堆上分配。

内存逃逸（Memory Escape）是指编译器将局部变量分配在堆上而不是栈上的情况

内存逃逸的主要影响是对性能的影响。相比栈上的分配，堆上的分配和垃圾回收代价更高，容易导致程序的运行速度变慢。
```

#### 产生逃逸发生的情况

1. **在方法内把局部变量指针返回** 
2. **发送指针或带有指针的值到 channel 中。**  在编译时，是没有办法知道哪个 `goroutine` 会在 `channel` 上接收数据。所以编译器没法知道变量什么时候才会被释放。
3. **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 `[]*string` 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
4. **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
5. **在 interface 类型上调用方法。**  在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

```

在计算机科学中，栈（Stack）和堆（Heap）是指用于管理内存的两个重要区域。

栈是一种具有特定规则的内存区域，用于存储程序运行时的局部变量和函数调用的上下文信息。栈的分配和释放是由编译器自动控制的。在函数调用时，每次进入一个新的函数，该函数的参数、局部变量和返回地址等信息将被压入栈顶。当函数返回时，相应的局部变量会被弹出栈，栈帧缩小。由于栈的分配和释放是自动控制的，所以栈上的内存分配和释放是非常高效的。

堆是指一块程序运行时用于动态分配内存的区域。在堆上分配的内存不会自动释放，需要程序员手动调用释放内存的操作。堆的分配和释放通常由动态内存管理器进行管理。在堆上分配内存的操作相对较慢，并且由于堆上的内存可以在任何时候被分配或释放，可能会导致内存碎片问题。

总的来说，栈上的内存分配是由编译器进行自动管理的，是一种自动化的内存管理方式，主要用于存储局部变量和函数调用的信息；而堆上的内存分配是由程序员手动进行管理的，在堆上分配的内存需要手动释放，并且由于动态分配的特点，堆的内存分配和释放速度相对较慢。

需要注意的是，栈和堆是指内存分配的方式和管理机制，并不局限于某种特定的数据结构或存储对象。
```

